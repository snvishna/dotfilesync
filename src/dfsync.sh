#!/usr/bin/env bash

# ==============================================================================
# Dotfilesync v3.0.1: Interactive Batch Sync
# Fixed: Prompts now work correctly by reading from /dev/tty
# ==============================================================================

set -o errexit
set -o nounset
set -o pipefail

# ------------------------------------------------------------------------------
# CONSTANTS
# ------------------------------------------------------------------------------
readonly VERSION="3.0.1"
readonly DOTFILESYNC_ROOT="${HOME}/.dotfilesync"
readonly CONFIG_PATH="${DOTFILESYNC_ROOT}/config.json"
readonly BACKUP_SUFFIX=".bak.$(date +%Y%m%d-%H%M%S)"
readonly GITHUB_API_URL="https://api.github.com"

# ANSI Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m'

# ------------------------------------------------------------------------------
# LOGGING
# ------------------------------------------------------------------------------
log_info()    { printf "${BLUE}[INFO]${NC} %s\n" "$1"; }
log_success() { printf "${GREEN}[SUCCESS]${NC} %s\n" "$1"; }
log_warn()    { printf "${YELLOW}[WARN]${NC} %s\n" "$1"; }
log_error()   { printf "${RED}[ERROR]${NC} %s\n" "$1" >&2; }
log_perf()    { printf "${CYAN}[PERF]${NC} %s\n" "$1"; }

# ------------------------------------------------------------------------------
# UTILS
# ------------------------------------------------------------------------------
check_dependencies() {
    for cmd in jq curl; do
        if ! command -v "$cmd" &> /dev/null; then
            log_error "Missing dependency: $cmd"
            exit 1
        fi
    done
}

get_os_type() { uname | tr '[:upper:]' '[:lower:]'; }

get_gist_filename() {
    echo "$1" | sed -e "s:~:.:g; s:/:.:g" | awk '{gsub(/[.]+/,".")}1'
}

backup_file() {
    [[ -f "$1" ]] && cp "$1" "${1}${BACKUP_SUFFIX}" && log_info "Backup: ${1}${BACKUP_SUFFIX}"
}

# ------------------------------------------------------------------------------
# KEYCHAIN
# ------------------------------------------------------------------------------
keychain_op() {
    local op="$1"
    local user="$2"
    local label="$3"
    local pass="${4:-}"
    local os
    os=$(get_os_type)

    case "$op" in
        add)
            if [[ "$os" == darwin* ]]; then
                security add-generic-password -a "$user" -s "$label" -w "$pass" -U || true
            else
                echo "$pass" | secret-tool store --label "$label" user "$user" usage "$label"
            fi
            ;;
        get)
            if [[ "$os" == darwin* ]]; then
                security find-generic-password -wga "$user" -s "$label" 2>/dev/null
            else
                secret-tool lookup user "$user" usage "$label"
            fi
            ;;
        delete)
            if [[ "$os" == darwin* ]]; then
                security delete-generic-password -a "$user" -s "$label" || true
            else
                secret-tool clear user "$user" usage "$label"
            fi
            ;;
    esac
}

# ------------------------------------------------------------------------------
# API CORE
# ------------------------------------------------------------------------------
github_request() {
    local method="$1"
    local endpoint="$2"
    local user="$3"
    local token="$4"
    local data="${5:-}"

    local args=("-s" "-u" "${user}:${token}" "-X" "${method}")
    [[ -n "$data" ]] && args+=("-d" "@-")

    if [[ -n "$data" ]]; then
        echo "$data" | curl "${args[@]}" "${GITHUB_API_URL}${endpoint}"
    else
        curl "${args[@]}" "${GITHUB_API_URL}${endpoint}"
    fi
}

# ------------------------------------------------------------------------------
# COMMANDS
# ------------------------------------------------------------------------------
cmd_setup() {
    check_dependencies
    [[ -f "$CONFIG_PATH" ]] && { log_error "Config exists at $CONFIG_PATH"; exit 1; }

    read -r -p "GitHub Username: " github_user
    read -s -p "GitHub Token (gist scope): " github_token
    echo ""

    keychain_op add "$github_user" "dotfiles_sync" "$github_token"

    local gist_fname
    gist_fname=$(get_gist_filename "$CONFIG_PATH")
    
    local raw_config
    raw_config=$(jq -n --arg u "$github_user" --arg p "$CONFIG_PATH" '{githubUser: $u, gistId: "", dotFilePaths: [$p]}')
    
    local payload
    payload=$(jq -n \
        --arg desc "Generated by dotfilesync utility" \
        --arg fname "$gist_fname" \
        --arg content "$raw_config" \
        '{description: $desc, public: false, files: {($fname): {content: $content}}}')

    log_info "Creating Gist..."
    local gist_id
    gist_id=$(github_request "POST" "/gists" "$github_user" "$github_token" "$payload" | jq -r ".id")

    if [[ "$gist_id" == "null" || -z "$gist_id" ]]; then
        log_error "Failed to create Gist."
        exit 1
    fi

    local final_config
    final_config=$(echo "$raw_config" | jq --arg id "$gist_id" '.gistId = $id')
    
    mkdir -p "$DOTFILESYNC_ROOT"
    echo "$final_config" | jq '.' > "$CONFIG_PATH"
    
    local update_payload
    update_payload=$(jq -n \
        --arg fname "$gist_fname" \
        --arg content "$final_config" \
        '{files: {($fname): {content: $content}}}')
        
    github_request "PATCH" "/gists/$gist_id" "$github_user" "$github_token" "$update_payload" >/dev/null
    log_success "Setup complete. Gist ID: $gist_id"
}

cmd_push() {
    local auto_yes="${1:-}"
    [[ ! -f "$CONFIG_PATH" ]] && { log_error "Config missing."; exit 1; }

    local config
    config=$(cat "$CONFIG_PATH")
    local user
    user=$(echo "$config" | jq -r ".githubUser")
    local id
    id=$(echo "$config" | jq -r ".gistId")
    local token
    token=$(keychain_op get "$user" "dotfiles_sync")
    [[ -z "$token" ]] && { log_error "Token missing in Keychain."; exit 1; }

    log_info "Preparing Batch Push..."
    local files_json="{}"

    while IFS= read -r filepath; do
        local expanded_path="${filepath/#\~/$HOME}"
        local gist_name
        gist_name=$(get_gist_filename "$filepath")

        # Interactive Check
        if [[ "$auto_yes" != "--yes" && "$auto_yes" != "-y" ]]; then
            # FIX: Read from /dev/tty to avoid consuming the loop input
            read -r -p "Push $filepath? [y/N] " confirm < /dev/tty
            [[ ! "$confirm" =~ ^[Yy] ]] && continue
        fi

        if [[ -f "$expanded_path" ]]; then
            local content
            content=$(cat "$expanded_path")
            files_json=$(echo "$files_json" | jq --arg fn "$gist_name" --arg ct "$content" '. + {($fn): {content: $ct}}')
            log_info "Queued: $filepath"
        else
            log_warn "Skipped (Missing): $filepath"
        fi
    done < <(echo "$config" | jq -r '.dotFilePaths[]')

    if [[ "$files_json" == "{}" ]]; then
        log_warn "No files selected for push."
        exit 0
    fi

    log_perf "Uploading batch payload..."
    local final_payload
    final_payload=$(jq -n --argjson f "$files_json" '{files: $f}')
    
    local response
    response=$(github_request "PATCH" "/gists/$id" "$user" "$token" "$final_payload")

    if echo "$response" | jq -e ".id" > /dev/null; then
        log_success "Batch Push Complete."
    else
        log_error "Upload failed: $(echo "$response" | jq -r .message)"
        exit 1
    fi
}

cmd_pull() {
    local auto_yes="${1:-}"
    [[ ! -f "$CONFIG_PATH" ]] && { log_error "Config missing."; exit 1; }

    local config
    config=$(cat "$CONFIG_PATH")
    local user
    user=$(echo "$config" | jq -r ".githubUser")
    local id
    id=$(echo "$config" | jq -r ".gistId")
    local token
    token=$(keychain_op get "$user" "dotfiles_sync")

    log_info "Fetching Gist Data..."
    local gist_json
    gist_json=$(github_request "GET" "/gists/$id" "$user" "$token")
    
    if [[ $(echo "$gist_json" | jq -r .message) == "Not Found" ]]; then
        log_error "Gist not found."
        exit 1
    fi

    while IFS= read -r filepath; do
        local expanded_path="${filepath/#\~/$HOME}"
        local gist_name
        gist_name=$(get_gist_filename "$filepath")

        if [[ "$auto_yes" != "--yes" && "$auto_yes" != "-y" ]]; then
            # FIX: Read from /dev/tty
            read -r -p "Overwrite $filepath? [y/N] " confirm < /dev/tty
            [[ ! "$confirm" =~ ^[Yy] ]] && continue
        fi

        local content
        content=$(echo "$gist_json" | jq -r ".files[\"$gist_name\"].content")

        if [[ "$content" != "null" ]]; then
            backup_file "$expanded_path"
            echo "$content" > "$expanded_path"
            log_success "Restored: $filepath"
        else
            log_warn "Remote file not found: $gist_name"
        fi
    done < <(echo "$config" | jq -r '.dotFilePaths[]')
}

cmd_cleanup() {
    [[ ! -f "$CONFIG_PATH" ]] && return
    local config
    config=$(cat "$CONFIG_PATH")
    local user
    user=$(echo "$config" | jq -r ".githubUser")
    keychain_op delete "$user" "dotfiles_sync"
    rm -f "$CONFIG_PATH"
    log_success "Cleanup complete."
}

# ------------------------------------------------------------------------------
# MAIN
# ------------------------------------------------------------------------------
case "${1:-}" in
    setup|SETUP)   cmd_setup ;;
    push|PUSH)     cmd_push "${2:-}" ;;
    pull|PULL)     cmd_pull "${2:-}" ;;
    cleanup)       cmd_cleanup ;;
    *)
        echo "Usage: dfsync {setup|push [-y]|pull [-y]|cleanup}"
        exit 1
        ;;
esac
